/*
 * Copyright (c) 2023.
 * Author Peter Placzek (tada5hi)
 * For the full copyright and license information,
 * view the LICENSE file that was distributed with this source code.
 */ var PriorityName;
(function(PriorityName) {
    PriorityName["LEFT"] = 'left';
    PriorityName["RIGHT"] = 'right';
})(PriorityName || (PriorityName = {}));

/*
 * Copyright (c) 2022.
 * Author Peter Placzek (tada5hi)
 * For the full copyright and license information,
 * view the LICENSE file that was distributed with this source code.
 */ function isObject(item) {
    return !!item && typeof item === 'object' && !Array.isArray(item);
}
function isSafeInput(object) {
    try {
        JSON.stringify(object);
        return true;
    } catch (e) {
        return false;
    }
}
function isSafeKey(key) {
    return key !== '__proto__' && key !== 'prototype' && key !== 'constructor';
}
function isEqual(x, y) {
    if (Object.is(x, y)) return true;
    if (x instanceof Date && y instanceof Date) {
        return x.getTime() === y.getTime();
    }
    if (x instanceof RegExp && y instanceof RegExp) {
        return x.toString() === y.toString();
    }
    if (isObject(x) && isObject(y)) {
        const keysX = Reflect.ownKeys(x);
        const keysY = Reflect.ownKeys(y);
        if (keysX.length !== keysY.length) {
            return false;
        }
        for(let i = 0; i < keysX.length; i++){
            const key = keysX[i];
            if (!Reflect.has(y, key) || !isEqual(x[key], y[key])) {
                return false;
            }
        }
        return true;
    }
    if (Array.isArray(x) && Array.isArray(y)) {
        if (x.length !== y.length) {
            return false;
        }
        for(let i = 0; i < x.length; i++){
            if (!isEqual(x[i], y[i])) {
                return false;
            }
        }
        return true;
    }
    return false;
}

function distinctArray(arr) {
    for(let i = 0; i < arr.length; i++){
        for(let j = arr.length - 1; j > i; j--){
            if (isEqual(arr[i], arr[j])) {
                arr.splice(j, 1);
            }
        }
    }
    return arr;
}
function mergeArrays(...sources) {
    return [].concat.apply([], [
        ...sources
    ]);
}
function mergeArraysDistinct(...sources) {
    return distinctArray(mergeArrays(...sources));
}

/*
 * Copyright (c) 2023.
 * Author Peter Placzek (tada5hi)
 * For the full copyright and license information,
 * view the LICENSE file that was distributed with this source code.
 */ function _extends$1() {
    _extends$1 = Object.assign || function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends$1.apply(this, arguments);
}
/* istanbul ignore next */ const gT = (()=>{
    if (typeof globalThis !== 'undefined') {
        return globalThis;
    }
    // eslint-disable-next-line no-restricted-globals
    if (typeof self !== 'undefined') {
        // eslint-disable-next-line no-restricted-globals
        return self;
    }
    if (typeof window !== 'undefined') {
        return window;
    }
    if (typeof global !== 'undefined') {
        return global;
    }
    throw new Error('unable to locate global object');
})();
/* istanbul ignore next */ function clone(value) {
    if (gT.structuredClone) {
        return gT.structuredClone(value);
    }
    /* istanbul ignore next */ if (isObject(value)) {
        return _extends$1({}, value);
    }
    /* istanbul ignore next */ if (Array.isArray(value)) {
        return [
            ...value
        ];
    }
    /* istanbul ignore next */ return value;
}

/*
 * Copyright (c) 2022.
 * Author Peter Placzek (tada5hi)
 * For the full copyright and license information,
 * view the LICENSE file that was distributed with this source code.
 */ function _extends() {
    _extends = Object.assign || function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
function cutObject(input, depth) {
    if (depth < 0) {
        return {};
    }
    const value = _extends({}, input);
    const keys = Object.keys(value);
    for(let i = 0; i < keys.length; i++){
        if (isObject(value[keys[i]])) {
            value[keys[i]] = cutObject(value[keys[i]], depth - 1);
        }
    }
    return value;
}

/*
 * Copyright (c) 2021.
 * Author Peter Placzek (tada5hi)
 * For the full copyright and license information,
 * view the LICENSE file that was distributed with this source code.
 */ // eslint-disable-next-line @typescript-eslint/ban-types
function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
}

function buildOptions(options) {
    options = options || {};
    var _options_array;
    options.array = (_options_array = options.array) != null ? _options_array : true;
    var _options_arrayDistinct;
    options.arrayDistinct = (_options_arrayDistinct = options.arrayDistinct) != null ? _options_arrayDistinct : false;
    var _options_clone;
    options.clone = (_options_clone = options.clone) != null ? _options_clone : false;
    var _options_inPlace;
    options.inPlace = (_options_inPlace = options.inPlace) != null ? _options_inPlace : false;
    options.priority = options.priority || PriorityName.LEFT;
    return options;
}

function baseMerger(options, ...sources) {
    let target;
    let source;
    if (options.priority === PriorityName.RIGHT) {
        target = sources.pop();
        source = sources.pop();
    } else {
        target = sources.shift();
        source = sources.shift();
    }
    if (!source) {
        if (Array.isArray(target) && options.arrayDistinct) {
            return distinctArray(target);
        }
        return target;
    }
    if (Array.isArray(target) && Array.isArray(source)) {
        target.push(...source);
        if (options.priority === PriorityName.RIGHT) {
            return baseMerger(options, ...sources, target);
        }
        return baseMerger(options, target, ...sources);
    }
    if (isObject(target) && isObject(source)) {
        const keys = Object.keys(source);
        for(let i = 0; i < keys.length; i++){
            const key = keys[i];
            if (hasOwnProperty(target, key)) {
                if (!isSafeKey(key)) {
                    continue;
                }
                if (options.strategy) {
                    const applied = options.strategy(target, key, source[key]);
                    if (typeof applied !== 'undefined') {
                        continue;
                    }
                }
                if (isObject(target[key]) && isObject(source[key])) {
                    if (!isSafeInput(source[key])) {
                        continue;
                    }
                    if (options.priority === PriorityName.RIGHT) {
                        target[key] = baseMerger(options, source[key], target[key]);
                    } else {
                        target[key] = baseMerger(options, target[key], source[key]);
                    }
                    continue;
                }
                if (options.array && Array.isArray(target[key]) && Array.isArray(source[key])) {
                    switch(options.priority){
                        case PriorityName.LEFT:
                            Object.assign(target, {
                                [key]: baseMerger(options, target[key], source[key])
                            });
                            break;
                        case PriorityName.RIGHT:
                            Object.assign(target, {
                                [key]: baseMerger(options, source[key], target[key])
                            });
                            break;
                    }
                }
            } else {
                Object.assign(target, {
                    [key]: source[key]
                });
            }
        }
    }
    if (options.priority === PriorityName.RIGHT) {
        return baseMerger(options, ...sources, target);
    }
    return baseMerger(options, target, ...sources);
}
function createMerger(input) {
    const options = buildOptions(input);
    return (...sources)=>{
        if (!sources.length) {
            throw new SyntaxError('At least one input element is required.');
        }
        if (options.clone) {
            return baseMerger(options, ...clone(sources));
        }
        if (!options.inPlace) {
            if (options.priority === PriorityName.LEFT) {
                if (Array.isArray(sources[0])) {
                    sources.unshift([]);
                } else {
                    sources.unshift({});
                }
            } else if (Array.isArray(sources[0])) {
                sources.push([]);
            } else {
                sources.push({});
            }
        }
        return baseMerger(options, ...sources);
    };
}
const merge = createMerger();

/**
 * Assign source attributes to a target object.
 *
 * @param target
 * @param sources
 */ function assign(target, ...sources) {
    return createMerger({
        inPlace: true,
        priority: 'left',
        array: false
    })(target, ...sources);
}

export { PriorityName, assign, buildOptions, clone, createMerger, cutObject, distinctArray, hasOwnProperty, isEqual, isObject, isSafeInput, isSafeKey, merge, mergeArrays, mergeArraysDistinct };
//# sourceMappingURL=index.mjs.map
